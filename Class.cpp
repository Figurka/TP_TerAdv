#pragma once // Включение происходит только 1 раз. не стандартная дирректива.предложил VS
#include <iostream> 
#include <SFML\Graphics.hpp>
#include "Class.h"

using namespace sf;


//////////MainClass//////////
	Smth:: Smth(Image &image, float X, float Y, int W, int H, std::string Name)
  {
	  x = X;
	  y = Y;
	   w = W; h = H;
	   name = Name;
	  MoveTimer = 0;
	   Speed = 0;
	   Health = 100; 
	   dx = 0; 
	   dy = 0;
    
	texture.loadFromImage(image); //заносим наше изображение в текстуру 
	  sprite.setTexture(texture); //заливаем спрайт текстурой
    sprite.setOrigin(w / 2, h / 2);
	};

	FloatRect Smth::getRect()
  { 
    FloatRect  FR ( x, y, w, h);
    return FR;  
  }



//////////Player//////////

	Player:: Player(Image &image, float X, float Y, int W, int H, std::string Name) :Smth(image, X, Y, W, H, Name)  //Конструктор с параметрами(формальными) для класса Player. При создании объекта класса мы будем задавать имя файла, координату Х и У, ширину и высоту
  { 
		Player:: playerScore = 0;
		 state = stay;
    if (Name == "Player1")
      { 
       //Задаем спрайту один прямоугольник для //вывода одного игрока.IntRect – для приведения типов 
         sprite.setTextureRect(IntRect(0,36, w, h)); 
      }
	};

  /*void Player::interactionWithMap()//ф-ция взаимодействия с картой
  {

    for (int i = y / 32; i < (y + h) / 32; i++)//проходимся по тайликам, контактирующим с игроком, то есть по всем квадратикам размера 32*32, которые мы окрашивали в 9 уроке. про условия читайте ниже.
      for (int j = x / 32; j<(x + w) / 32; j++)//икс делим на 32, тем самым получаем левый квадратик, с которым персонаж соприкасается. (он ведь больше размера 32*32, поэтому может одновременно стоять на нескольких квадратах). А j<(x + w) / 32 - условие ограничения координат по иксу. то есть координата самого правого квадрата, который соприкасается с персонажем. таким образом идем в цикле слева направо по иксу, проходя по от левого квадрата (соприкасающегося с героем), до правого квадрата (соприкасающегося с героем)
      {
        if (TileMap[i][j] == '1'  )//если наш квадратик соответствует символу 0 (стена), то проверяем "направление скорости" персонажа:
        {
          if ( dy > 0)//если мы шли вниз,
          {
            y = i * 32 - h;//то стопорим координату игрек персонажа. сначала получаем координату нашего квадратика на карте(стены) и затем вычитаем из высоты спрайта персонажа.
          }
          if (dy<0)
          {
            y = i * 32 + 32;//аналогично с ходьбой вверх. dy<0, значит мы идем вверх (вспоминаем координаты паинта)
          }
          if (dx > 0)
          {
            x = j * 32 - w;//если идем вправо, то координата Х равна стена (символ 0) минус ширина персонажа
          }
          if (dx < 0)
          {
            x = j * 32 + 32;//аналогично идем влево
          }
        }



  
      }

  };*/

  void Player::update(float time) //функция "оживления" объекта класса. update - обновление. принимает в себя время SFML , вследствие чего работает бесконечно, давая персонажу движение.
  {
    switch (dir)//реализуем поведение в зависимости от направления. (каждая цифра соответствует направлению)
    {
    case 0: dx = Speed; dy = 0;   break;//по иксу задаем положительную скорость, по игреку зануляем. получаем, что персонаж идет только вправо
    case 1: dx = -Speed; dy = 0;   break;//по иксу задаем отрицательную скорость, по игреку зануляем. получается, что персонаж идет только влево
    case 2: dx = 0; dy = Speed;   break;//по иксу задаем нулевое значение, по игреку положительное. получается, что персонаж идет только вниз
    case 3: dx = 0; dy = -Speed;   break;//по иксу задаем нулевое значение, по игреку отрицательное. получается, что персонаж идет только вверх
    }

    x += dx * time;//то движение из прошлого урока. наше ускорение на время получаем смещение координат и как следствие движение
    y += dy * time;//аналогично по игреку
    //interactionWithMap();
    Speed = 0;//зануляем скорость, чтобы персонаж остановился.
    sprite.setPosition(x, y); //выводим спрайт в позицию x y , посередине. бесконечно выводим в этой функции, иначе бы наш спрайт стоял на месте.
  }
;




//////////Enemy//////////
 



//////////Bullet//////////